# Python项目软件设计流程和规范经验指导

本文档基于 `ai-anki-cards` 项目的实践经验，总结了一套完整的Python项目设计流程和开发规范，可作为后续新项目的参考模板。

## 目录

- [项目结构设计](#项目结构设计)
- [代码组织原则](#代码组织原则)
- [代码质量工具链](#代码质量工具链)
- [类型提示与文档规范](#类型提示与文档规范)
- [测试策略](#测试策略)
- [错误处理与日志](#错误处理与日志)
- [依赖管理](#依赖管理)
- [安全考虑](#安全考虑)
- [开发工作流](#开发工作流)
- [专业性要求](#专业性要求)
- [可维护性要求](#可维护性要求)
- [可读性要求](#可读性要求)
- [交互性要求](#交互性要求)
- [文档要求](#文档要求)

---

## 项目结构设计

### 标准目录结构

```
project_name/
├── project_name/          # 主包目录
│   ├── __init__.py
│   ├── __main__.py        # CLI入口（如果适用）
│   ├── cli.py             # Typer CLI命令定义（如果适用）
│   ├── core/              # 核心业务逻辑
│   │   ├── __init__.py
│   │   ├── engine.py      # 核心引擎
│   │   ├── providers/     # 提供商抽象（依赖倒置）
│   │   │   ├── __init__.py
│   │   │   ├── base.py    # 抽象基类
│   │   │   └── concrete.py # 具体实现
│   │   └── ...
│   ├── models/            # 数据模型（Pydantic）
│   │   ├── __init__.py
│   │   ├── config.py      # 配置模型
│   │   └── data.py        # 业务数据模型
│   ├── cli/               # CLI子命令模块（如果CLI较复杂）
│   │   ├── __init__.py
│   │   ├── config_handler.py
│   │   └── ...
│   ├── utils/             # 工具函数
│   │   ├── __init__.py
│   │   ├── logger.py      # 日志配置
│   │   └── cache.py       # 缓存工具
│   ├── exceptions.py      # 自定义异常
│   └── config/            # 配置文件
│       └── default.yaml
├── tests/                 # 测试目录
│   ├── __init__.py
│   ├── conftest.py        # pytest配置和共享fixtures
│   ├── fixtures/          # 测试数据
│   │   ├── sample.txt
│   │   └── sample.md
│   ├── integration/       # 集成测试
│   │   └── __init__.py
│   └── test_*.py          # 单元测试
├── scripts/               # 自动化脚本
│   ├── check_code_quality.sh
│   └── quick_check.sh
├── pyproject.toml        # 项目配置（现代Python标准）
├── README.md
├── DEVELOPMENT.md        # 开发指南
├── CONTRIBUTING.md       # 贡献指南
├── TOOLS_QUICK_START.md  # 工具快速参考
└── .pre-commit-config.yaml # Pre-commit配置
```

### 设计原则

#### 1. 模块化设计

- **按功能划分模块**：每个模块有明确的职责
- **避免循环依赖**：使用依赖注入和接口抽象
- **最小化模块间耦合**：通过接口和配置解耦

**示例**：
```python
# core/providers/base.py - 抽象基类
from abc import ABC, abstractmethod

class BaseLLMProvider(ABC):
    """LLM提供商抽象基类"""

    def __init__(self, config: LLMConfig):
        self.config = config

    @abstractmethod
    async def generate(self, prompt: str) -> str:
        """生成文本"""
        pass

# core/providers/openai_compatible.py - 具体实现
class OpenAICompatibleProvider(BaseLLMProvider):
    async def generate(self, prompt: str) -> str:
        """实现OpenAI兼容的生成逻辑"""
        ...
```

#### 2. 单一职责原则（SRP）

每个模块、类、函数只做一件事：

```python
# ✅ 好的设计：职责单一
class CardGenerator:
    """只负责卡片生成逻辑"""
    async def generate_cards(
        self,
        content: str,
        config: GenerationConfig
    ) -> List[Card]:
        ...

class CardFilter:
    """只负责卡片过滤"""
    def filter_cards(self, cards: List[Card]) -> List[Card]:
        ...

class CardDeduplicator:
    """只负责卡片去重"""
    def deduplicate(self, cards: List[Card]) -> List[Card]:
        ...

# ❌ 不好的设计：职责过多
class CardProcessor:
    """处理所有卡片相关操作"""
    async def generate_cards(self, ...): ...
    def filter_cards(self, ...): ...
    def deduplicate_cards(self, ...): ...
    def export_cards(self, ...): ...
```

#### 3. 依赖倒置原则（DIP）

高层模块不依赖低层模块，都依赖抽象：

```python
# ✅ 好的设计：依赖抽象
class CardGenerator:
    def __init__(self, llm_provider: BaseLLMProvider):  # 依赖抽象
        self.provider = llm_provider

# ❌ 不好的设计：依赖具体实现
class CardGenerator:
    def __init__(self):
        self.provider = OpenAIProvider()  # 硬编码依赖
```

#### 4. 接口隔离原则（ISP）

使用小而专的接口，避免臃肿的接口：

```python
# ✅ 好的设计：小而专的接口
class Cache(ABC):
    @abstractmethod
    def get(self, key: str) -> Optional[str]:
        """获取缓存"""
        pass

    @abstractmethod
    def set(self, key: str, value: str) -> None:
        """设置缓存"""
        pass

# ❌ 不好的设计：臃肿的接口
class Storage(ABC):
    @abstractmethod
    def get(self, key: str) -> Optional[str]: ...
    @abstractmethod
    def set(self, key: str, value: str) -> None: ...
    @abstractmethod
    def delete(self, key: str) -> None: ...
    @abstractmethod
    def list(self, prefix: str) -> List[str]: ...
    # ... 很多不需要的方法
```

---

## 代码组织原则

### 1. 包结构组织

- **core/**: 核心业务逻辑，不依赖外部框架
- **models/**: 数据模型定义（使用Pydantic）
- **utils/**: 通用工具函数
- **cli/**: CLI相关代码（如果适用）
- **exceptions.py**: 自定义异常类

### 2. 导入顺序规范

遵循PEP 8导入顺序（由Ruff自动处理）：

```python
# 1. 标准库
import asyncio
from pathlib import Path
from typing import List, Optional

# 2. 第三方库
import typer
from loguru import logger
from pydantic import BaseModel

# 3. 本地应用/库
from ankigen.core.card_generator import CardGenerator
from ankigen.models.card import Card
```

### 3. 命名规范

- **模块名**: 小写，下划线分隔（`card_generator.py`）
- **类名**: 驼峰命名（`CardGenerator`）
- **函数/变量名**: 小写，下划线分隔（`generate_cards`）
- **常量**: 全大写，下划线分隔（`MAX_RETRIES`）
- **私有成员**: 单下划线前缀（`_internal_method`）

---

## 代码质量工具链

### 工具选择

| 工具 | 用途 | 替代方案 | 速度 |
|------|------|----------|------|
| **Ruff** | 代码检查+格式化 | flake8+isort+black | ⚡⚡⚡ 极快 |
| **MyPy** | 类型检查 | - | ⚡⚡ 快 |
| **Pydocstyle** | 文档字符串检查 | - | ⚡⚡ 快 |
| **Bandit** | 安全扫描 | - | ⚡⚡ 快 |
| **Safety** | 依赖漏洞扫描 | - | ⚡ 中等 |

### 配置文件：pyproject.toml

现代Python项目统一使用 `pyproject.toml` 管理所有配置：

```toml
[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[tool.setuptools]
packages = ["project_name"]

[tool.setuptools.package-data]
project_name = ["config/**/*", "templates/**/*"]

[project]
name = "project_name"
version = "0.1.0"
description = "项目描述"
readme = "README.md"
requires-python = ">=3.8"
license = "MIT"
dependencies = [
    "typer>=0.9.0",
    "pydantic>=2.0.0",
    "pydantic-settings>=2.0.0",
    "aiohttp>=3.9.0",
    "loguru>=0.7.0",
    "python-dotenv>=1.0.0",
    "tqdm>=4.66.0",
    "pyyaml>=6.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.4.0",
    "pytest-asyncio>=0.21.0",
    "pytest-cov>=4.1.0",
    "pytest-xdist>=3.3.0",
    "pytest-mock>=3.12.0",
    "ruff>=0.1.0",
    "mypy>=1.5.0",
    "pydocstyle>=6.3.0",
    "pre-commit>=3.4.0",
    "bandit>=1.7.5",
    "safety>=2.3.5",
]
lint = ["ruff>=0.1.0", "mypy>=1.5.0", "pydocstyle>=6.3.0"]
security = ["bandit>=1.7.5", "safety>=2.3.5"]

[project.scripts]
project_name = "project_name.cli:app"

# Ruff配置
[tool.ruff]
line-length = 100
target-version = "py38"

[tool.ruff.lint]
select = [
    "E",   # pycodestyle errors
    "F",   # pyflakes
    "I",   # isort
    "N",   # pep8-naming
    "W",   # pycodestyle warnings
    "UP",  # pyupgrade
    "B",   # flake8-bugbear
    "C4",  # flake8-comprehensions
    "SIM", # flake8-simplify
    "ARG", # flake8-unused-arguments
    "PIE", # flake8-pie
    "T20", # flake8-print
    "PT",  # flake8-pytest-style
    "Q",   # flake8-quotes
    "RUF", # ruff-specific rules
]
ignore = [
    "E501",  # line too long (handled by formatter)
    "B008",  # do not perform function calls in argument defaults
    "B904",  # raise without from (typer.Exit is intentional)
    "ARG001", # unused function argument (may be used by frameworks)
    "ARG002", # unused method argument
]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "auto"

[tool.ruff.lint.per-file-ignores]
"__init__.py" = ["F401"]  # unused imports allowed in __init__.py
"tests/**/*.py" = ["ARG", "F401", "S101"]  # allow unused args, imports, and assert in tests

# MyPy配置
[tool.mypy]
python_version = "3.9"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = false  # 渐进式类型检查
disallow_incomplete_defs = true
check_untyped_defs = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true
show_error_codes = true
show_error_context = true

[[tool.mypy.overrides]]
module = [
    "genanki.*",
    "frontmatter.*",
    "tiktoken.*",
]
ignore_missing_imports = true

# Pytest配置
[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
asyncio_mode = "auto"
addopts = "--cov=project_name --cov-report=html --cov-report=term-missing --cov-report=xml"

# Bandit配置
[tool.bandit]
exclude_dirs = ["tests", "venv", ".venv", "build", "dist"]
skips = ["B101"]  # assert_used (allowed in tests)

# Pydocstyle配置
[tool.pydocstyle]
convention = "google"
match = "(?!test_).*\\.py"
match_dir = "(?!tests|venv|\\.venv|build|dist)"
```

### Pre-commit Hooks

创建 `.pre-commit-config.yaml`：

```yaml
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files

  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.1.0
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.7.0
    hooks:
      - id: mypy
        additional_dependencies: [types-all]
        args: [--ignore-missing-imports]
        always_run: false  # 可选，不阻止提交

  - repo: local
    hooks:
      - id: bandit
        name: bandit
        entry: bandit
        language: system
        args: [-r, project_name/]
        pass_filenames: false
        always_run: false
```

安装和使用：

```bash
# 安装pre-commit
pip install pre-commit

# 安装hooks
pre-commit install

# 手动运行所有hooks
pre-commit run --all-files
```

### 自动化脚本

创建 `scripts/check_code_quality.sh`：

```bash
#!/bin/bash
set -e

echo "=========================================="
echo "代码质量检查"
echo "=========================================="

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

ERRORS=0

# 1. Ruff检查
echo "1. Ruff检查..."
if ruff check project_name/; then
    echo -e "${GREEN}✓ Ruff检查通过${NC}"
else
    echo -e "${RED}✗ Ruff检查失败${NC}"
    ERRORS=$((ERRORS + 1))
fi

# 2. Ruff格式化检查
echo "2. Ruff格式化检查..."
if ruff format --check project_name/; then
    echo -e "${GREEN}✓ 代码格式正确${NC}"
else
    echo -e "${YELLOW}⚠ 代码格式需要调整${NC}"
fi

# 3. MyPy类型检查
echo "3. MyPy类型检查..."
if mypy project_name/; then
    echo -e "${GREEN}✓ MyPy检查通过${NC}"
else
    echo -e "${YELLOW}⚠ MyPy发现类型问题（非致命）${NC}"
fi

# 4. Pydocstyle文档检查
echo "4. Pydocstyle文档检查..."
if pydocstyle project_name/; then
    echo -e "${GREEN}✓ 文档字符串检查通过${NC}"
else
    echo -e "${YELLOW}⚠ 文档字符串需要改进${NC}"
fi

# 5. Bandit安全扫描
echo "5. Bandit安全扫描..."
if bandit -r project_name/ -ll; then
    echo -e "${GREEN}✓ Bandit安全检查通过${NC}"
else
    echo -e "${YELLOW}⚠ Bandit发现潜在安全问题${NC}"
fi

# 6. 运行测试
echo "6. 运行测试..."
if pytest --cov=project_name --cov-report=term-missing; then
    echo -e "${GREEN}✓ 所有测试通过${NC}"
else
    echo -e "${RED}✗ 测试失败${NC}"
    ERRORS=$((ERRORS + 1))
fi

# 总结
echo "=========================================="
if [ $ERRORS -eq 0 ]; then
    echo -e "${GREEN}✓ 所有关键检查通过！${NC}"
    exit 0
else
    echo -e "${RED}✗ 发现 $ERRORS 个关键错误${NC}"
    exit 1
fi
```

---

## 类型提示与文档规范

### 类型提示规范

**全面使用类型提示**：

```python
from typing import List, Optional, Dict, Tuple, AsyncIterator
from pathlib import Path

# 函数参数和返回值
async def generate_cards(
    content: str,
    config: GenerationConfig,
    output_dir: Optional[Path] = None,
) -> Tuple[List[Card], GenerationStats]:
    """
    生成卡片

    Args:
        content: 输入内容
        config: 生成配置
        output_dir: 输出目录（可选）

    Returns:
        (卡片列表, 统计信息) 元组

    Raises:
        CardGenerationError: 当生成失败时
    """
    ...

# 类属性类型提示
class CardGenerator:
    def __init__(self, llm_config: LLMConfig, cache: Optional[FileCache] = None):
        self.llm_config: LLMConfig = llm_config
        self.cache: Optional[FileCache] = cache
        self.cards: List[Card] = []
```

### 文档字符串规范（Google风格）

```python
class CardGenerator:
    """
    卡片生成器

    负责调用LLM生成卡片，解析响应，并进行质量过滤和去重。

    Attributes:
        llm_config: LLM配置对象
        cache: 缓存对象（可选）
        cards: 生成的卡片列表
    """

    def generate_cards(
        self,
        content: str,
        config: GenerationConfig,
    ) -> List[Card]:
        """
        生成卡片

        从输入内容生成指定数量的卡片。如果需要的卡片数量超过单次请求限制，
        会自动切分内容并多次调用API。

        Args:
            content: 输入内容，可以是文本或Markdown格式
            config: 生成配置，包含卡片类型、数量、难度等参数

        Returns:
            生成的卡片列表

        Raises:
            CardGenerationError: 当LLM调用失败或解析失败时
            ValidationError: 当配置参数无效时

        Example:
            >>> generator = CardGenerator(llm_config)
            >>> cards = await generator.generate_cards(
            ...     content="Python是一种编程语言",
            ...     config=GenerationConfig(card_type="basic", card_count=5)
            ... )
            >>> len(cards)
            5
        """
        ...
```

### Pydantic模型文档

```python
from pydantic import BaseModel, Field

class LLMConfig(BaseModel):
    """
    LLM配置模型

    包含模型提供商、API密钥、请求参数等配置。

    Attributes:
        provider: LLM提供商（openai/deepseek/ollama等）
        model_name: 模型名称
        api_key: API密钥（可选，可从环境变量获取）
        temperature: 温度参数（0.0-2.0）
        max_tokens: 最大token数
    """

    provider: LLMProvider = Field(
        default=LLMProvider.DEEPSEEK,
        description="LLM提供商"
    )
    model_name: str = Field(
        default="deepseek-chat",
        description="模型名称"
    )
    api_key: Optional[str] = Field(
        default=None,
        description="API密钥（优先从环境变量获取）"
    )
    temperature: float = Field(
        default=0.7,
        ge=0.0,
        le=2.0,
        description="温度参数"
    )
```

---

## 测试策略

### 测试金字塔

```
        /\
       /  \      E2E测试（少量）
      /____\
     /      \    集成测试（适量）
    /________\
   /          \  单元测试（大量）
  /____________\
```

### 测试组织

```
tests/
├── __init__.py
├── conftest.py          # 共享fixtures和配置
├── fixtures/            # 测试数据文件
│   ├── sample.txt
│   └── sample.md
├── integration/         # 集成测试
│   ├── __init__.py
│   └── test_end_to_end.py
└── test_*.py            # 单元测试
    ├── test_card_generator.py
    ├── test_llm_engine.py
    └── test_parser.py
```

### conftest.py 配置

```python
"""
Pytest配置和共享fixtures

提供测试中使用的共享fixtures和配置。
"""
import os
from pathlib import Path
from typing import Generator

import pytest

@pytest.fixture()
def test_data_dir() -> Path:
    """返回测试数据目录路径"""
    return Path(__file__).parent / "fixtures"

@pytest.fixture()
def sample_txt_file(test_data_dir: Path) -> Path:
    """返回示例文本文件路径"""
    return test_data_dir / "sample.txt"

@pytest.fixture()
def sample_md_file(test_data_dir: Path) -> Path:
    """返回示例Markdown文件路径"""
    return test_data_dir / "sample.md"

@pytest.fixture()
def tmp_output_dir(tmp_path: Path) -> Path:
    """返回临时输出目录"""
    output_dir = tmp_path / "output"
    output_dir.mkdir()
    return output_dir

@pytest.fixture(autouse=True)
def _reset_env() -> Generator[None, None, None]:
    """在每个测试前后重置环境变量"""
    original_env = os.environ.copy()
    yield
    os.environ.clear()
    os.environ.update(original_env)
```

### 单元测试示例

```python
"""
卡片生成器测试
"""
import pytest
from unittest.mock import AsyncMock, MagicMock, patch

from ankigen.core.card_generator import CardGenerator
from ankigen.models.config import LLMConfig, LLMProvider, GenerationConfig
from ankigen.models.card import Card

class TestCardGenerator:
    """卡片生成器测试类"""

    @pytest.fixture()
    def llm_config(self):
        """创建LLM配置fixture"""
        return LLMConfig(
            provider=LLMProvider.DEEPSEEK,
            model_name="deepseek-chat",
            api_key="test_key",
        )

    @pytest.fixture()
    def generator(self, llm_config):
        """创建卡片生成器fixture"""
        return CardGenerator(llm_config)

    @pytest.mark.asyncio()
    async def test_generate_cards(self, generator):
        """测试生成卡片"""
        # Mock LLM响应
        mock_response = '{"cards": [{"Front": "问题", "Back": "答案"}]}'

        with patch.object(
            generator.llm_engine.provider,
            "generate_with_retry",
            new_callable=AsyncMock
        ) as mock_generate:
            mock_generate.return_value = mock_response

            cards, stats = await generator.generate_cards(
                content="测试内容",
                config=GenerationConfig(card_type="basic", card_count=1)
            )

            assert len(cards) == 1
            assert cards[0].front == "问题"
            assert cards[0].back == "答案"
```

### 集成测试示例

```python
"""
端到端集成测试
"""
import pytest
from pathlib import Path

from ankigen.core.card_generator import CardGenerator
from ankigen.models.config import LLMConfig, GenerationConfig, LLMProvider

@pytest.mark.integration()
class TestEndToEnd:
    """端到端测试"""

    @pytest.mark.asyncio()
    async def test_full_generation_flow(self, sample_md_file, tmp_output_dir):
        """测试完整的生成流程"""
        # 读取测试文件
        content = sample_md_file.read_text()

        # 创建生成器（使用真实配置，但可以mock API调用）
        config = LLMConfig(
            provider=LLMProvider.DEEPSEEK,
            model_name="deepseek-chat",
            api_key="test_key",
        )
        generator = CardGenerator(config)

        # 执行生成（需要mock API调用）
        # ...
```

### 测试覆盖率

```bash
# 运行测试并生成覆盖率报告
pytest --cov=project_name --cov-report=html --cov-report=term-missing

# 设置覆盖率阈值
pytest --cov=project_name --cov-fail-under=80
```

---

## 错误处理与日志

### 自定义异常层次结构

```python
"""
自定义异常类模块

定义项目专用的异常类层次结构，提供结构化的错误处理。
"""

class ProjectError(Exception):
    """项目基础异常类

    所有项目特定异常的基类。
    """

class ConfigurationError(ProjectError):
    """配置错误异常

    当配置加载、验证或处理失败时抛出。
    """

class ProviderError(ProjectError):
    """提供商错误异常

    当外部API调用失败、认证失败或其他提供商相关错误时抛出。
    """

class GenerationError(ProjectError):
    """生成错误异常

    当生成过程中发生错误时抛出。
    """

class ValidationError(ProjectError):
    """验证错误异常

    当数据验证失败时抛出。
    """
```

### 结构化异常处理

```python
from ankigen.exceptions import (
    CardGenerationError,
    ConfigurationError,
    ProviderError,
)
from loguru import logger

async def generate_cards(...) -> List[Card]:
    """生成卡片"""
    try:
        # 验证配置
        if not config.is_valid():
            raise ConfigurationError("配置无效")

        # 调用LLM
        response = await self.llm_engine.generate(prompt)

        # 解析响应
        cards = self.parse_response(response)

        return cards

    except ProviderError as e:
        logger.error(f"LLM提供商错误: {e}")
        raise CardGenerationError(f"生成失败: {e}") from e
    except ValidationError as e:
        logger.error(f"验证错误: {e}")
        raise CardGenerationError(f"数据验证失败: {e}") from e
    except Exception as e:
        logger.exception("生成卡片时发生未知错误")
        raise CardGenerationError(f"未知错误: {e}") from e
```

### 日志配置（使用loguru）

```python
"""
日志配置模块

使用loguru配置日志系统，支持彩色输出和文件日志。
"""
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional

from loguru import logger

def setup_logger(
    level: str = "INFO",
    log_file: Optional[Path] = None,
    rotation: str = "10 MB",
    retention: str = "7 days",
    verbose: bool = False,
    auto_log_file: bool = True,
) -> Optional[Path]:
    """
    配置loguru日志系统

    Args:
        level: 日志级别（DEBUG, INFO, WARNING, ERROR, CRITICAL）
        log_file: 日志文件路径，如果为None且auto_log_file=True则自动创建
        rotation: 日志文件轮转大小
        retention: 日志文件保留时间
        verbose: 是否显示详细日志（DEBUG级别）
        auto_log_file: 如果log_file为None，是否自动创建日志文件

    Returns:
        实际使用的日志文件路径，如果没有创建日志文件则返回None
    """
    # 移除默认处理器
    logger.remove()

    # 控制台输出格式
    console_format = (
        "<green>{time:YYYY-MM-DD HH:mm:ss}</green> | "
        "<level>{level: <8}</level> | "
        "<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> | "
        "<level>{message}</level>"
    )

    # 文件输出格式（更详细）
    file_format = (
        "{time:YYYY-MM-DD HH:mm:ss.SSS} | {level: <8} | "
        "{name}:{function}:{line} | {message}"
    )

    # 设置控制台输出
    log_level = "DEBUG" if verbose else level
    logger.add(
        sys.stderr,
        format=console_format,
        level=log_level,
        colorize=True,
        backtrace=True,
        diagnose=True,
    )

    # 设置文件输出
    actual_log_file = log_file
    if actual_log_file is None and auto_log_file:
        # 自动创建日志文件：在项目根目录的logs目录下
        project_root = Path(__file__).parent.parent.parent
        logs_dir = project_root / "logs"
        logs_dir.mkdir(parents=True, exist_ok=True)

        # 使用时间戳创建日志文件名
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        actual_log_file = logs_dir / f"project_{timestamp}.log"

    if actual_log_file:
        actual_log_file = Path(actual_log_file)
        try:
            actual_log_file.parent.mkdir(parents=True, exist_ok=True)
            logger.add(
                actual_log_file,
                format=file_format,
                level=level,
                rotation=rotation,
                retention=retention,
                compression="zip",
                backtrace=True,
                diagnose=True,
            )
            logger.info(f"日志文件已创建: {actual_log_file}")
            return actual_log_file
        except Exception as e:
            logger.warning(f"无法创建日志文件 {actual_log_file}: {e}")
            return None

    return None
```

### 日志使用示例

```python
from loguru import logger

# 不同级别的日志
logger.debug("调试信息：变量值 = {}", variable_value)
logger.info("处理完成，生成了 {} 张卡片", card_count)
logger.warning("API响应格式异常，尝试备用解析方法")
logger.error("生成失败：{}", error_message)
logger.exception("发生异常")  # 自动包含堆栈跟踪

# 结构化日志
logger.bind(user_id=123, request_id="abc").info("处理用户请求")
```

---

## 依赖管理

### pyproject.toml 依赖配置

```toml
[project]
name = "project_name"
version = "0.1.0"
requires-python = ">=3.8"
dependencies = [
    "typer>=0.9.0",           # CLI框架
    "pydantic>=2.0.0",        # 数据验证
    "pydantic-settings>=2.0.0", # 配置管理
    "aiohttp>=3.9.0",         # 异步HTTP客户端
    "loguru>=0.7.0",          # 日志
    "python-dotenv>=1.0.0",   # 环境变量管理
    "tqdm>=4.66.0",           # 进度条
    "pyyaml>=6.0.0",          # YAML解析
]

[project.optional-dependencies]
dev = [
    "pytest>=7.4.0",
    "pytest-asyncio>=0.21.0",
    "pytest-cov>=4.1.0",
    "pytest-xdist>=3.3.0",    # 并行测试
    "pytest-mock>=3.12.0",    # Mock工具
    "ruff>=0.1.0",
    "mypy>=1.5.0",
    "pydocstyle>=6.3.0",
    "pre-commit>=3.4.0",
    "bandit>=1.7.5",
    "safety>=2.3.5",
]
lint = ["ruff>=0.1.0", "mypy>=1.5.0", "pydocstyle>=6.3.0"]
security = ["bandit>=1.7.5", "safety>=2.3.5"]
```

### 虚拟环境管理

```bash
# 创建虚拟环境
python -m venv venv

# 激活虚拟环境
# Linux/Mac:
source venv/bin/activate
# Windows:
venv\Scripts\activate

# 安装项目（开发模式）
pip install -e ".[dev]"

# 或分别安装
pip install -e ".[lint]"      # 代码质量工具
pip install -e ".[security]"  # 安全扫描工具
```

---

## 安全考虑

### 1. 代码安全扫描（Bandit）

```bash
# 扫描代码
bandit -r project_name/

# 只显示中高危
bandit -r project_name/ -ll

# 生成HTML报告
bandit -r project_name/ -f html -o bandit-report.html
```

配置（pyproject.toml）：
```toml
[tool.bandit]
exclude_dirs = ["tests", "venv", ".venv", "build", "dist"]
skips = ["B101"]  # assert_used (allowed in tests)
```

### 2. 依赖漏洞扫描（Safety）

```bash
# 检查当前环境的依赖
safety check

# 检查requirements文件
safety check --file requirements.txt

# 更新漏洞数据库
safety check --update
```

### 3. API密钥安全

**❌ 错误做法**：
```python
# 硬编码密钥
api_key = "sk-1234567890abcdef"
```

**✅ 正确做法**：
```python
import os
from python_dotenv import load_dotenv

# 从环境变量获取
load_dotenv()
api_key = os.getenv("API_KEY")

# 或使用pydantic-settings
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    api_key: str

    class Config:
        env_file = ".env"
```

### 4. 输入验证

使用Pydantic进行输入验证：

```python
from pydantic import BaseModel, Field, field_validator

class UserInput(BaseModel):
    content: str = Field(..., min_length=1, max_length=10000)
    card_count: int = Field(..., ge=1, le=100)

    @field_validator("content")
    @classmethod
    def validate_content(cls, v: str) -> str:
        # 检查恶意内容
        if "DROP TABLE" in v.upper():
            raise ValueError("检测到潜在SQL注入")
        return v
```

---

## 开发工作流

### 1. 项目初始化

```bash
# 1. 创建项目目录
mkdir project_name && cd project_name

# 2. 初始化git仓库
git init

# 3. 创建虚拟环境
python -m venv venv
source venv/bin/activate

# 4. 创建pyproject.toml（参考上面的模板）

# 5. 安装开发依赖
pip install -e ".[dev]"

# 6. 设置pre-commit hooks
pre-commit install

# 7. 创建项目结构（参考上面的目录结构）
mkdir -p project_name/{core,models,utils,config}
mkdir -p tests/{fixtures,integration}
mkdir -p scripts
```

### 2. 日常开发流程

```bash
# 1. 创建功能分支
git checkout -b feature/new-feature

# 2. 开发代码...

# 3. 提交前检查（pre-commit会自动运行）
git add .
git commit -m "feat: 添加新功能"
# pre-commit hooks会自动运行

# 4. 如果pre-commit失败，修复后重新提交
ruff check --fix project_name/
ruff format project_name/
git add .
git commit -m "feat: 添加新功能"

# 5. 运行完整测试
pytest --cov=project_name

# 6. 推送代码
git push origin feature/new-feature
```

### 3. 代码审查前检查清单

```bash
# 运行所有检查
./scripts/check_code_quality.sh

# 或手动运行
ruff check project_name/ && \
ruff format --check project_name/ && \
mypy project_name/ && \
pydocstyle project_name/ && \
bandit -r project_name/ -ll && \
pytest --cov=project_name --cov-fail-under=80
```

---

## 专业性要求

### 1. 充分利用现有成熟的库与工具

- **CLI框架**: Typer（现代、类型安全）
- **数据验证**: Pydantic（强大的数据验证和序列化）
- **异步HTTP**: aiohttp（高性能异步HTTP客户端）
- **日志**: loguru（简单易用的日志库）
- **进度条**: tqdm（美观的进度显示）
- **配置管理**: pydantic-settings（类型安全的配置管理）

### 2. 代码逻辑清晰专业

- 使用设计模式（工厂模式、策略模式等）
- 清晰的抽象层次
- 合理的错误处理
- 完善的类型系统

### 3. 代码鲁棒性强

- 输入验证
- 异常处理
- 重试机制
- 优雅降级
- 边界情况处理

---

## 可维护性要求

### 1. 代码模块化设计、分文件管理

- 按功能划分模块
- 单一职责原则
- 避免过大的文件（建议<500行）
- 清晰的模块边界

### 2. 完善的错误处理与异常处理

- 自定义异常层次结构
- 结构化异常处理
- 友好的错误消息
- 详细的日志记录

### 3. 完善的日志记录（loguru）

- 结构化日志
- 不同级别的日志
- 日志文件自动轮转
- 日志查询和分析

---

## 可读性要求

### 1. 简洁清晰直观的注释

- 文档字符串（Google风格）
- 关键逻辑的注释
- 复杂算法的说明
- 避免冗余注释

### 2. 清晰的类型注释

- 所有函数参数和返回值
- 类属性类型
- 使用typing模块的类型
- MyPy类型检查

### 3. 遵循代码风格要求

- PEP 8规范
- Ruff自动格式化
- 一致的命名规范
- 合理的代码组织

---

## 交互性要求

### 1. 清晰简洁的命令行参数与交互（Typer）

```python
import typer

app = typer.Typer()

@app.command()
def generate(
    input: Path = typer.Option(..., "--input", "-i", help="输入文件路径"),
    output: Path = typer.Option(..., "--output", "-o", help="输出文件路径"),
    verbose: bool = typer.Option(False, "--verbose", help="显示详细日志"),
):
    """生成卡片"""
    ...
```

### 2. 命令行输出简洁清晰美观

- 使用typer.echo进行输出
- 使用颜色和格式（typer.style）
- 清晰的进度提示
- 友好的错误消息

### 3. 用进度条显示进度（tqdm）

```python
from tqdm import tqdm

# 文件处理进度
with tqdm(total=file_count, desc="处理文件") as pbar:
    for file in files:
        process_file(file)
        pbar.update(1)

# API调用进度
with tqdm(total=len(chunks), desc="生成卡片") as pbar:
    for chunk in chunks:
        await generate_chunk(chunk)
        pbar.update(1)
```

---

## 文档要求

### 1. README.md

- 项目概述和功能特性
- 安装说明
- 快速开始示例
- 使用示例
- 配置说明
- 常见问题

### 2. DEVELOPMENT.md

- 开发环境设置
- 代码质量工具使用
- 测试指南
- 提交规范
- 常见问题

### 3. CONTRIBUTING.md

- 贡献指南
- 代码规范
- 测试要求
- PR流程

### 4. TOOLS_QUICK_START.md

- 工具快速参考
- 常用命令
- 故障排除

### 5. API文档

- 模块文档字符串
- 函数和方法说明
- 使用示例
- 参数说明

---

## 测试要求

### 1. 编写简单的测试脚本/demo脚本

创建 `demo.py` 或 `examples/` 目录：

```python
"""
演示脚本

展示如何使用项目的主要功能。
"""
from ankigen.core.card_generator import CardGenerator
from ankigen.models.config import LLMConfig, GenerationConfig, LLMProvider

async def main():
    """主函数"""
    # 创建配置
    llm_config = LLMConfig(
        provider=LLMProvider.DEEPSEEK,
        model_name="deepseek-chat",
        api_key="your_api_key",
    )

    # 创建生成器
    generator = CardGenerator(llm_config)

    # 生成卡片
    cards, stats = await generator.generate_cards(
        content="Python是一种编程语言",
        config=GenerationConfig(card_type="basic", card_count=5)
    )

    print(f"生成了 {len(cards)} 张卡片")

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```

### 2. 在tests目录下编写单元测试与集成测试

- **单元测试**: 测试单个函数/方法
- **集成测试**: 测试模块间协作
- **覆盖率**: >=80%

### 3. 对核心逻辑要有单元测试

- 核心业务逻辑
- 数据处理
- 错误处理
- 边界情况

### 4. 对程序整体逻辑与功能进行集成测试

- 端到端流程
- CLI命令
- 文件处理
- API集成

---

## 总结

### 核心原则

1. **模块化设计**：按功能划分模块，单一职责
2. **依赖倒置**：依赖抽象而非具体实现
3. **类型安全**：全面使用类型提示
4. **测试驱动**：单元测试+集成测试
5. **自动化**：代码质量检查自动化
6. **安全优先**：代码扫描+依赖扫描

### 工具链总结

- **代码检查与格式化**：Ruff（替代flake8+isort+black）
- **类型检查**：MyPy
- **文档检查**：Pydocstyle
- **安全扫描**：Bandit + Safety
- **测试框架**：Pytest + pytest-asyncio + pytest-cov
- **Git Hooks**：Pre-commit
- **配置管理**：pyproject.toml（现代Python标准）

### 最佳实践

1. ✅ 使用 `pyproject.toml` 统一管理配置
2. ✅ 设置 pre-commit hooks 自动化检查
3. ✅ 编写全面的类型提示和文档字符串
4. ✅ 使用 Pydantic 进行数据验证
5. ✅ 使用 loguru 进行结构化日志
6. ✅ 自定义异常层次结构
7. ✅ 编写单元测试和集成测试
8. ✅ 定期运行安全扫描
9. ✅ 使用成熟的第三方库
10. ✅ 提供清晰的CLI接口和进度显示

---

## 参考资源

- [PEP 8 - Style Guide for Python Code](https://peps.python.org/pep-0008/)
- [PEP 517 - Build System](https://peps.python.org/pep-0517/)
- [Ruff Documentation](https://docs.astral.sh/ruff/)
- [MyPy Documentation](https://mypy.readthedocs.io/)
- [Pydantic Documentation](https://docs.pydantic.dev/)
- [Pytest Documentation](https://docs.pytest.org/)
- [Pre-commit Documentation](https://pre-commit.com/)
- [Typer Documentation](https://typer.tiangolo.com/)
- [Loguru Documentation](https://loguru.readthedocs.io/)
